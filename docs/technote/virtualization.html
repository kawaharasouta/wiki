

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ハイパーバイザ仮想化に関する内容 &mdash; wiki  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'ja',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="コンテナ技術周辺について" href="container.html" />
    <link rel="prev" title="ブートローダについてのメモ" href="boot.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> wiki
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contents/dpdk.html">DPDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/kvm.html">kvm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/vagrant.html">vagrant</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/docker.html">Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/ssh_config.html">ssh_config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/c_c++.html">c, c++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/golang.html">golang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/ocaml.html">OCamlについてとりあえずメモ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/xdp.html">XDP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/ovs.html">Open vSwitch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/ovs.html#ovs-dpdk">OvS DPDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/trex.html">TRex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/openvpn.html">OpenVPN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/system_programing.html">システムプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/autotools.html">autotools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/freebsd.html">freebsd関連のメモする場所</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/dhcp.html">DHCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/syslog.html">syslogについて</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/capabilities.html">Linux capabilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/haskell.html">haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents/XDG.html">XDG Base Directry</a></li>
</ul>
<p class="caption"><span class="caption-text">Technote:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="rss.html">linuxのRSSに関して</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupt.html">NICの割り込みについて</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_packet.html">linuxのパケットの送受信について</a></li>
<li class="toctree-l1"><a class="reference internal" href="boot.html">ブートローダについてのメモ</a></li>
<li class="toctree-l1"><a class="reference internal" href="boot.html#grub2">GRUB2</a></li>
<li class="toctree-l1"><a class="reference internal" href="boot.html#id4">カーネルが起動した後どうなってるのって話</a></li>
<li class="toctree-l1"><a class="reference internal" href="boot.html#systemd">systemd</a></li>
<li class="toctree-l1"><a class="reference internal" href="boot.html#boot">bootに関するまとめ</a></li>
<li class="toctree-l1"><a class="reference internal" href="boot.html#vmlinuzinitrd-img">vmlinuzとかinitrd.imgとかがよくわからないので調べたやつ</a></li>
<li class="toctree-l1"><a class="reference internal" href="boot.html#virt-install-ubuntu2020">virt-install でubuntu2020がインストールできなかった話</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">ハイパーバイザ仮想化に関する内容</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">仮想化の問題点</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">初期の回答について</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xen">Xenの準仮想化について</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpu">CPUの仮想化支援</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">自分のしばらく悩んでいたこと</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">ハイパーバイザに関して</a></li>
<li class="toctree-l2"><a class="reference internal" href="#paravirtualization-virtio">準仮想化(paravirtualization)とvirtioに関して</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">完全仮想化が遅い理由</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vmx-non-root-modevmx-root-mode">VMX non-root mode・VMX root mode間のモード遷移にかかるコスト</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">デバイスエミュレーションの呼び出しにかかるコスト</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#virtio">virtio関連について</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id8">virtioの概要</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vhost">vhostとは</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vhost-user">vhost-user</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vhost-user-server-client">vhost-user server と client</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#virtio-vhost-user">virtio-vhost-user</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memo">memo</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#kvm">kvmのコードのディレクトリ</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="container.html">コンテナ技術周辺について</a></li>
<li class="toctree-l1"><a class="reference internal" href="unikernel.html">unikernelについて</a></li>
<li class="toctree-l1"><a class="reference internal" href="cs.html">related computer science</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuntap.html">TUN/TAPの調査</a></li>
<li class="toctree-l1"><a class="reference internal" href="auth.html">Linuxの認証周りの話</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpu.html">CPU関連のメモ</a></li>
<li class="toctree-l1"><a class="reference internal" href="fpga.html">FPGA関連</a></li>
<li class="toctree-l1"><a class="reference internal" href="standard.html">規格とか思想とか</a></li>
<li class="toctree-l1"><a class="reference internal" href="golang_perf.html">golangでちょっと文字列関連性能計測した時のいろんなメモ</a></li>
<li class="toctree-l1"><a class="reference internal" href="virsh_source.html">virshのソースコードを読んだ時のメモ</a></li>
</ul>
<p class="caption"><span class="caption-text">cheetsheets:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cheetsheets/bash.html">bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cheetsheets/ip_command.html">ip command</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cheetsheets/vim.html">vim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cheetsheets/vim.html#neovim">neovim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cheetsheets/vim.html#vim-plugin">vim pluginの作り方</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cheetsheets/kernel.html">カーネル関連tips</a></li>
</ul>
<p class="caption"><span class="caption-text">system tracing:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../system_tracing/dtrace.html">DTrace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system_tracing/systemtap.html">systemtap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system_tracing/bpf.html">BPF</a></li>
</ul>
<p class="caption"><span class="caption-text">documents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../documents/tex.html">Tex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documents/sphinx.html">sphinx</a></li>
</ul>
<p class="caption"><span class="caption-text">test:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../test/doc.html">test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test/doc.html#include">include</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">wiki</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>ハイパーバイザ仮想化に関する内容</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/technote/virtualization.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>ハイパーバイザ仮想化に関する内容<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>※ここでの話は基本的にKVM/QEMUの話が前提．そうでない場合は注釈をつける．※</p>
<div class="section" id="id2">
<h2>仮想化の問題点<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>現代のマシンの3大コンポーネントは CPU・メモリ・(データ/デバイス)IO の3つである．
仮想マシンを動かすということは，上記の3つをなんらかの方法により動いているように見せるというものである．
IOはハードウェアエミュレータで取り合えず仮想化ができそうだ．
メモリはCPUがどうにかなればCPUの保護機能でどうにかしてくれそうだし，そうでなくてもOSが持ってるメモリプロテクション機能とかあるし
なんかよろしくやってくれそうな感じがする．
となるとCPUである．
とりあえず動作すればいいだけならハードウェアエミュレータでCPUをエミュレートすれば良いのでなんだかこれも達成できそうであるが，
ここでCPUをエミュレートすることをもうちょっと掘り下げて考える．
仮想マシンのinstructionはあるユーザランドのエミュレータで実行されようとする．
それはエミュレータによってユーザランドのプロセスとして処理される．
それはカーネル空間に入って処理がなされる．
CPUに~~~~~~
こう考えると，仮想マシン上ではたった一つのinstructionが，実プロセッサではどれだけ大量のinstructionnに増えていることだろう．
コンテキストスイッチもあるしリングプロテクションの遷移もあるし，
本当に実行したいinstructionを実行するのにどれだけの余剰のinstructionが生まれるのだろう．
こういうわけでパフォーマンスの問題が大きくのしかかることになる．
完全仮想化には大きなパフォーマンスの犠牲が伴うのである．
じゃあ至極単純に仮想マシンのinstructionも実プロセッサに丸投げしようと思うとまた違う問題が発生する．
基本的にOSはリングプロテクションのring0で実行されることになっている．
これは，実ハードの全てのリソースに対して操作権限を持っているということである．
これでは，ホストOSや他のゲストOSに対して変更を加えてしまうようなことが起こりえない．
よってこの方法はダメ．</p>
<p>ではこの問題をどうやって解決するか．
一つの回答が準仮想化である．
さらにもう一つの回答がCPUの仮想化支援である．
それについて説明する．</p>
<p>2020.10.01追記
初期の回答についても少しだけ加える．</p>
<div class="section" id="id3">
<h3>初期の回答について<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>「動的バイナリトランスレーション」というらしい．
仮想化ソフトウェアがVMのセンシティブ命令をトラップして，ring3の命令としてCPUに投げる．
今考えれば，VTをソフトウェア実装した感じののり．
今でもソフトウェアで仮想化するときには使われている手法で，
QEMUとかは今でもこの方式のはず．
また，(ここで書くことではない気がするけど)
KVMはQEMUを基本的に利用していてCPUエミュレーションだけひったくってるみたいなイメージであってるはず．
そのため，メモリとかディスクとかPCIとか他のエミュレーションは(特に変なことしてなければ)QEMUを使っているはず．</p>
</div>
<div class="section" id="xen">
<h3>Xenの準仮想化について<a class="headerlink" href="#xen" title="Permalink to this headline">¶</a></h3>
<p>Xenの仮想化手法について説明する．
Xenは準仮想化，すなわち，ゲストOSに一部改変を加えることによって仮想化を実現している．
具体的には，OSが実行されるリングプロテクションの権限を変更することである．
例えば通常のLinuxでは，カーネル(OS)空間はring0，ユーザ空間はring3で実行されている．
これをカーネル空間はring1で実行されるように変更を行う．
この時もちろんハイパーバイザであるXenはring0である．
これにより他に影響を与えることを防ぐことができる．
ただしこれはOSに変更を加える必要がある．</p>
</div>
<div class="section" id="cpu">
<h3>CPUの仮想化支援<a class="headerlink" href="#cpu" title="Permalink to this headline">¶</a></h3>
<p>Intel-VTとかの話をするんだけど今時間ないから後でするね．
ring -1 なのかなあ．</p>
</div>
<div class="section" id="id4">
<h3>自分のしばらく悩んでいたこと<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>CPUを完全仮想化した場合はなんとなく仮想マシンの動作の主体みたいなものがわかる．
当然ユーザプロセスなんだからホストでプロセスとして処理されてるんだろうなって感じ．
じゃあ，仮想化支援使った場合どうなんだろうって話．
実プロセッサにinstructionがオフロードされるのはまあいいんだけど，動作の主体みたいなものがわからなくて混乱した．</p>
<p>じゃあ例えば，ゲストが特になんのプロセスも持ってなかった時，(普通はなんらかのデーモンが動いてるはずだけど今は考えない．後で考える)
この時は特にプロセスは何も動いてないから
当然vCPUも特になんのinstructionも実行しないから実CPUでゲストのinstructionが発生してる訳も無い．
この状態から何かあった時，何かあった時っていうのはこういう場合は必ずハードウェアからの入出力が伴ってるはずなので
kvmから割り込みがVMに怒ってVMenterしてるはずだよね．だから動作の主体というか発端はkvmになるわけだ．
そのkvmプロセスからVMenterしたinstructionが実プロセッサ上で実行されているとこういうわけな気がしてる．
デーモンの時も簡単で，これが何かの操作で起動した場合は必ずハードウェアからの入出力が伴ってるから↑と一緒．
起動時のデーモンだったらそもそもの起動時，電源が入ってvcpuが動いてMBRを読み出すくらいのところでVMExitしそうだし，その発端の命令って
間違いなくkvmが出してそうだからそういうことだよね．</p>
<p>また，特にCPU関連以外について，<a class="reference external" href="https://www.redhat.com/ja/blog/introduction-virtio-networking-and-vhost-net">https://www.redhat.com/ja/blog/introduction-virtio-networking-and-vhost-net</a> にて以下のような記述もあった．</p>
<p>メモリマネージャ、スケジューラ、ネットワークスタックなどのハイパーバイザコンポーネントがLinuxカーネルの一部として提供されます。
VMは、ネットワークアダプタなどの専用の仮想ハードウェアを使用して、標準のLinuxスケジューラによってスケジュールされた通常のLinuxプロセスです。
(the hypervisor components such as memory manager, scheduler, network stack, etc. are provided as part of the Linux kernel. The VMs are regular Linux processes scheduled by a standard Linux scheduler with dedicated virtual hardware such as network adapters.)</p>
<p>ゲストVMはqemuプロセスの内部で実行されています。
qemuプロセスはホストユーザ空間上で実行されているプロセスで、libvirt(ユーザ空間アプリケーション)やKVM(ホストカーネル)と通信します。
(The guest VM is running inside the qemu process, which is simply a process running on the host user space and communicates with libvirt (user space application) and KVM (host kernel).)</p>
<p>qemu プロセスは各ゲスト VM 用に作成されるので、N 個の VM を作成すると N 個の qemu プロセスが作成され、libvirt はそれぞれの VM と通信します。
(A qemu process is created for each guest VM so if you create N VMs you will have N qemu processes, and libvirt will communicate with each of them. )</p>
<p>どうも動作の主体はqemuプロセスでやっぱりいいのか．</p>
</div>
</div>
<div class="section" id="id5">
<h2>ハイパーバイザに関して<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>そのうちハイパーバイザに関するVMenter/exitとかnonrootとかintel-VTとかそこらへんのことを書くけど今は書いてない</p>
<p>ちなみに，VMCSはVMの数だけ用意されるとshuu先生の資料にあったが，あれはおそらく間違いで，vcpuの数だけ存在するはずだ．</p>
<p>intel-VTはVMX-rootモードとVMX-non-rootモードを追加するもの．それはそうなのだが，どうやら別の見方があるようだ．
一部の見解では，「リングプロテクションにring0よりも上の特権階層を加えるもの」という見解があるらしい．
これは非常に大きなポイントである．
今までは，</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/before.png"><img alt="../_images/before.png" src="../_images/before.png" style="width: 346.40000000000003px; height: 278.8px;" /></a>
</div>
<p>だと思ってたのが実は</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/after.png"><img alt="../_images/after.png" src="../_images/after.png" style="width: 549.6px; height: 434.8px;" /></a>
</div>
<p>というような風になっている可能性があるということである．
つまりどういうことかというと，ハイパーバイザとホストカーネル空間は今まで同じ位置だと思ってた
(なんならハイパーバイザはホストカーネルサブセットだと思ってた)
のが，ハイパーバイザが一番高い特権レベルに存在することになるということである．
また，これってリングプロテクションとVMX-root, non-rootは並列に存在するものなのか同じ概念を別に表記してるだけなのにこんがらがってるのか
そういうのがよくわからん．
でも普通に考えてHOSTはVMX-rootであるような気がするから上の図は違う気がするんだけど，
いやていうかこの緑の下の図のリングプロテクションの番号だとゲストOSに変更加わっちゃうからこれは絶対に違う．</p>
<p>とりあえずshuu先生の</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/shuu-vt.png"><img alt="../_images/shuu-vt.png" src="../_images/shuu-vt.png" style="width: 167.20000000000002px; height: 143.20000000000002px;" /></a>
</div>
<p>には途轍もない違和感を感じるようになってしまった．</p>
<p>色々考えた結果，</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/my-vt.png"><img alt="../_images/my-vt.png" src="../_images/my-vt.png" style="width: 511.20000000000005px; height: 458.0px;" /></a>
</div>
<p>とすると，OSにプロテクションの番号の変更もなくなんとなくいい感じになってる気もするんだ．
もっと調査が必要だ．</p>
</div>
<div class="section" id="paravirtualization-virtio">
<h2>準仮想化(paravirtualization)とvirtioに関して<a class="headerlink" href="#paravirtualization-virtio" title="Permalink to this headline">¶</a></h2>
<p>すでに述べた(ことになっている)通り，通常の仮想化の際はハードウェアに対するIOは全てハードウェアのシミュレーションが行われる．
これにより，従来のドライバをそのまま使用することができるため，可用性?を担保できる．このような物を完全仮想化とかいう．
ところでこのハードウェアをエミュレートする方式は，ハードウェア操作のたびにVMexitが発生してしまうため，効率的ではない．
そこで，エミュレーションによる性能低下を図るものが準仮想化(paravirtualization)であり，
その(Linuxでの)フレームワークがvirtioである．</p>
<div class="section" id="id6">
<h3>完全仮想化が遅い理由<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>ハードウェア操作はその主たる部分がレジスタ操作である．仮想環境でもそれは同じであり，ハードウェア操作の際には
数回のレジスタ操作が行われる．
また，ハードウェアをエミュレーションするとは，ハードウェアの持つべきレジスタ群を持ちそれらの動作に関する定義を持つことである．
ところで，ハードウェアのエミュレーションはQEMUによって行われる．QEMUはホストOS上の(ユーザ)プロセスである．
ホストOSがハードウェア操作を行う場合，ホストのメモリ空間にアクセスすることになるため，
VMexitしてハイパーバイザにハードウェアレジスタアクセスをエミュレートしてもらう必要があり，
エミュレートが終わるとVMenterされ動作がゲストOSに帰ってくる．
この一連の動作は仮想環境でのみ起こる操作であるため，実ハードウェアとの性能差が出ます．</p>
<p>(以下，一般的なハイパーバイザ環境でのIO性能低下についての引用)</p>
<div class="section" id="vmx-non-root-modevmx-root-mode">
<h4>VMX non-root mode・VMX root mode間のモード遷移にかかるコスト<a class="headerlink" href="#vmx-non-root-modevmx-root-mode" title="Permalink to this headline">¶</a></h4>
<p>ハードウェアレジスタアクセス時のVMExitとゲスト再開時のVMEntryでは，
それぞれVMX non-root modeとVMX root modeの間でモード遷移が発生します．
この遷移のコストはCPUの進化に伴い小さくなってきているものの，VMExit・VMEntryにそれぞれ1000サイクルほど消費します．</p>
</div>
<div class="section" id="id7">
<h4>デバイスエミュレーションの呼び出しにかかるコスト<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>多くの場合，ハイパーバイザのデバイスエミュレータはユーザプロセス上で動作しています．
このため，ハードウェアレジスタアクセスをエミュレートするにはカーネルモードからユーザモードへ遷移し，
エミュレーションを行ってからカーネルモード へ戻ってくる必要があります．</p>
<p>また，ユーザプロセスはプロセススケジューラが適切と判断したタイミングで実行されるため，
VMExit直後にデバイスエミュレータのプロセスが実行される保証はありません．</p>
<p>同様に，ゲスト再開のVMEntryについてもデバイスエミュレーション終了直後に行われる保証はなく，
スケジューリング待ちになる可能性もあります．</p>
<p>また，たいていの完全仮想化デバイスでは一度のI/Oに複数回レジスタアクセスを行う必要があります
(たとえば，あるNICの受信処理では5〜6回のレジスタアクセスが必要になります)．
レジスタアクセスを行うたびに，上述の処理が発生し，大きなコストがかかります．
高速なI/Oが求められるデバイスの場合には，ここが性能上のボトルネックになります．</p>
<p>(以上，ハイパーバイザの作り方～ちゃんと理解する仮想化技術～ 第１１回 virtioによる準仮想化デバイス
その１「virtioの概要とVirtio PCI」より引用)</p>
</div>
</div>
</div>
</div>
<div class="section" id="virtio">
<h1>virtio関連について<a class="headerlink" href="#virtio" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://wiki.libvirt.org/page/Virtio">https://wiki.libvirt.org/page/Virtio</a></p>
<div class="section" id="id8">
<h2>virtioの概要<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>virtio_pciっていうのがなんかPCIデバイスをエミュレートしてる見たいな立ち回りをする感じ．
実際のデータやりとりはvirtio ringっていうメモリ領域でやる．これはshared memory空間にいて，
完全仮想化の場合はデータのやりとり(つまりレジスタ操作)の際に必ず逐一VMExitを発生させる必要があったけど，
共有メモリだからそれがないはず．
virtqueueはvirtioのキュー構造体．</p>
</div>
<div class="section" id="vhost">
<h2>vhostとは<a class="headerlink" href="#vhost" title="Permalink to this headline">¶</a></h2>
<p>この文章はかなりの不確実な成分を含んでいるのであとで必ず書き直す．
virtioと並んでvhostという準仮想ドライバがある．
virtioはバックエンドにQEMUを用いるが，vhostはカーネル空間にバックエンドが存在する．
vhost-net module enables KVM (QEMU) to offload the servicing of virtio-net devices to the vhost-net kernel module
そのため，ringプロテクション遷移が少ない．
とりあえず今の所QEMUを使わないvirtioという風に認識している．
でこれのネットワークインタフェース実装がvhost-net
たぶん，vhostはゲストから見るとvirtioとはなんら違いがないんじゃないか．
ゲストから見たらvirtioって見えてそう．多分virtio_pciが見えてるだろうし．
↑これはおそらく正しくて今までのvirtioのメカニズムが使われている．</p>
<p>vhostは、ゲストネットワークトラフィックをカーネル側から直接TUNデバイスに直接渡すことにより、上記のプロセスを加速できます。 このモデルでは、QEMUはvirtqueueの直接制御をカーネルドライバーに渡します。</p>
</div>
<div class="section" id="vhost-user">
<h2>vhost-user<a class="headerlink" href="#vhost-user" title="Permalink to this headline">¶</a></h2>
<p>上のvhostのDPDKアプライアンスのための実装としてvhost-userなるものがあるらしい．
vhostでカーネル空間にあったバックエンドをユーザ空間に持ち出すことにより，ホストでのDPDKの利用可能性を高めたもの．</p>
<div class="section" id="vhost-user-server-client">
<h3>vhost-user server と client<a class="headerlink" href="#vhost-user-server-client" title="Permalink to this headline">¶</a></h3>
<p>DPDK v16.07でvHostユーザークライアントモードが導入され、DPDKの制限に対処しました。これにより、vHostユーザーバックエンド（DPDKを備えたOVSなどのDPDKベースのアプリケーション）がクラッシュまたは再起動した場合、DPDK vHostユーザーポートを備えたVM バックエンドとの接続を確立し、基本的にネットワークの観点からは役に立たないようにします。 vHostユーザークライアントモードはこの問題を解決します。
とりあえずclient使っとけばいいよみたいな感じ．
要は，DPDKアプライアンスがvhost-userの主体?になる(clientはQEMUらしい)とそれがクラッシュした時に再現が大変になるから
serverは別にいてDPDKアプライアンスはclientとしてそれ(serverはQEMU)を利用するような形態にしたということ．</p>
</div>
</div>
<div class="section" id="virtio-vhost-user">
<h2>virtio-vhost-user<a class="headerlink" href="#virtio-vhost-user" title="Permalink to this headline">¶</a></h2>
<p>なんか，VM間の通信に強いようなやつっぽくて，
一つのゲストに対してvhostのバックエンドをオフロードしてるっぽくて，VM-VMの通信がホストを介さないでできているような感じのものっぽい．
<a class="reference external" href="https://wiki.qemu.org/Features/VirtioVhostUser">https://wiki.qemu.org/Features/VirtioVhostUser</a></p>
</div>
<div class="section" id="memo">
<h2>memo<a class="headerlink" href="#memo" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>virtioのゲスト側の実装はVMM側の実装とは別れている．
ゲストマシンはvirtioのドライバを持っていてかつVMM側でvirtioのバックエンドドライバが動いている必要がある．
なんかvritioだのvhostうんたらだのあるけどゲストはともかくvirtioだと思っておけばいいよってやつ．</li>
</ul>
<div class="section" id="kvm">
<h3>kvmのコードのディレクトリ<a class="headerlink" href="#kvm" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">virt</span><span class="o">/</span><span class="n">kvm</span><span class="o">/</span> <span class="n">アーキテクチャ非依存コード</span>
<span class="o">/</span><span class="n">arch</span><span class="o">/*/</span><span class="n">kvm</span><span class="o">/</span> <span class="n">各アーキテクチャ向けコード</span>
</pre></div>
</div>
<p>** x86向けの注意点 **
x86はIntel-VTとAMD-VTで互換性がないのでそれぞれの依存コードとx86共通のコードがある．
ここら辺説明分書くよりもそのディレクトリに置いてあるMakefile見た方が早い．/arch/x86/kvm/Makefileみろ．</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="container.html" class="btn btn-neutral float-right" title="コンテナ技術周辺について" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="boot.html" class="btn btn-neutral float-left" title="ブートローダについてのメモ" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, KAWAHARAsouta

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>